


PGF90 (Version     13.5)          07/18/2014  14:45:15      page 1

Switches: -noasm -nodclchk -debug -nodlines -line -list
          -idir /usr/mpi/pgi/mvapich2-1.7-qlc/include
          -idir /usr/mpi/pgi/mvapich2-1.7-qlc/include
          -inform severe -opt 2 -nosave -object -noonetrip
          -depchk on -nostandard     
          -symbol -noupcase    

Filename: parse.f90

(    1) !Crown Copyright 2012 AWE.
(    2) !
(    3) ! This file is part of CloverLeaf.
(    4) !
(    5) ! CloverLeaf is free software: you can redistribute it and/or modify it under 
(    6) ! the terms of the GNU General Public License as published by the 
(    7) ! Free Software Foundation, either version 3 of the License, or (at your option) 
(    8) ! any later version.
(    9) !
(   10) ! CloverLeaf is distributed in the hope that it will be useful, but 
(   11) ! WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
(   12) ! FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
(   13) ! details.
(   14) !
(   15) ! You should have received a copy of the GNU General Public License along with 
(   16) ! CloverLeaf. If not, see http://www.gnu.org/licenses/.
(   17) 
(   18) !>  @brief String manipulation utilities
(   19) !>  @author Wayne Gaudin
(   20) !>  @details Provides utilities to manipulate and parse Fortran strings.
(   21) 
(   22) MODULE clover_case_change
(   23) 
(   24) USE data_module
(   25) 
(   26) CONTAINS
(   27) 
(   28) FUNCTION tolower(string) RESULT (tolower_result)
(   29) 
(   30)   IMPLICIT NONE
(   31)   CHARACTER (LEN=*), INTENT(IN) :: string
(   32)   CHARACTER (LEN=LEN(string)) :: tolower_result
(   33)   INTEGER         :: i,ii
(   34) 
(   35)   DO i=1,len(string)
(   36)     ii=IACHAR(string(i:i))
(   37)     SELECT CASE (ii)
(   38)       CASE (65:90)
(   39)         tolower_result(i:i)=ACHAr(ii+32)
(   40)       CASE DEFAULT
(   41)         tolower_result(i:i)=string(i:i)
(   42)     END SELECT
(   43)   ENDDO
(   44) 
(   45) END FUNCTION TOLOWER
(   46) 
(   47) FUNCTION toupper(string) RESULT (toupper_result)
(   48) 
(   49)   IMPLICIT NONE
(   50)   CHARACTER (LEN=*), INTENT(IN) :: string






PGF90 (Version     13.5)          07/18/2014  14:45:15      page 2

(   51)   CHARACTER (LEN=LEN(string)) :: toupper_result
(   52)   INTEGER         :: i,ii
(   53) 
(   54)   DO i=1,LEN(string)
(   55)     ii=IACHAR(string(i:i))
(   56)     SELECT CASE (ii)
(   57)       CASE (97:122)
(   58)         toupper_result(i:i)=ACHAR(ii-32)
(   59)       CASE DEFAULT
(   60)         toupper_result(i:i)=string(i:i)
(   61)     END SELECT
(   62)   ENDDO
(   63) 
(   64) END FUNCTION toupper
(   65) 
(   66) END MODULE clover_case_change
(   67) 
(   68) MODULE clover_isitanint_mod
(   69) 
(   70) CONTAINS
(   71) 
(   72) FUNCTION isitanint(instring) RESULT(isitanint_result)
(   73) 
(   74)   IMPLICIT NONE
(   75) 
(   76)   CHARACTER(LEN=*), INTENT(IN) :: instring
(   77)   LOGICAL :: isitanint_result
(   78) 
(   79)   INTEGER         :: i,ii
(   80) 
(   81)   isitanint_result=.TRUE.
(   82) 
(   83)   DO i=1,LEN(instring)
(   84)     ii=IACHAR(instring(i:i))
(   85)     SELECT CASE(ii)
(   86)       CASE (43,45,48:57)
(   87)         IF(i.NE.1) THEN
(   88)           IF(ii.EQ.43 .OR.ii.EQ.45) isitanint_result=.FALSE.
(   89)         ENDIF
(   90)       CASE DEFAULT
(   91)         isitanint_result=.FALSE.
(   92)     END SELECT
(   93)   ENDDO
(   94) 
(   95) END FUNCTION isitanint
(   96) 
(   97) END MODULE clover_isitanint_mod
(   98) 
(   99) MODULE parse_module
(  100) 
(  101)   USE data_module
(  102)   USE report_module
(  103) 
(  104)   IMPLICIT NONE
(  105) 
(  106)   INTEGER, PARAMETER :: len_max=g_len_max &
(  107)                        ,dummy=0
(  108) 






PGF90 (Version     13.5)          07/18/2014  14:45:15      page 3

(  109)   INTEGER         :: iu ! Current unit number.
(  110) 
(  111)   CHARACTER(LEN=len_max) :: mask   &
(  112)                            ,line   &
(  113)                            ,here   &
(  114)                            ,sel    &
(  115)                            ,rest
(  116) CONTAINS
(  117) 
(  118) FUNCTION parse_init(iunit,cmask)
(  119) 
(  120)   ! Initialise for new set of reads.
(  121) 
(  122)   IMPLICIT NONE
(  123) 
(  124)   INTEGER :: parse_init
(  125) 
(  126)   INTEGER         :: iunit
(  127)   CHARACTER(LEN=*)  :: cmask
(  128) 
(  129)   INTEGER :: ios
(  130) 
(  131)   iu=iunit
(  132)   mask=cmask ! Set mask for which part of the file we are interested in.
(  133)   line=''
(  134)   here=''
(  135)   rest=''
(  136) 
(  137)   REWIND(UNIT=iunit,IOSTAT=ios)
(  138) 
(  139)   parse_init=ios
(  140) 
(  141) END FUNCTION parse_init
(  142) 
(  143) FUNCTION parse_getline(dummy)
(  144) 
(  145)   IMPLICIT NONE
(  146) 
(  147)   INTEGER :: parse_getline
(  148)   INTEGER        ,INTENT(IN) :: dummy
(  149) 
(  150)   INTEGER                :: s,ios,i,parse_out
(  151)   CHARACTER(LEN=len_max) :: l,nugget,string_temp1,string_temp2
(  152) 
(  153)   DO 
(  154)     READ(UNIT=iu,IOSTAT=ios,FMT='(a150)') l ! Read in next line.
(  155) 
(  156)     parse_getline=ios
(  157) 
(  158)     IF(parse_getline.NE.0) RETURN
(  159) 
(  160)       DO i=1,len_trim(l)
(  161)         if (IACHAR(l(i:)).LT.32.OR.IACHAR(l(i:i)).GT.128) l(i:i)=' '
(  162)       ENDDO
(  163) 
(  164)       l=TRIM(ADJUSTL(l))
(  165) 
(  166)       s=SCAN(l,'!')






PGF90 (Version     13.5)          07/18/2014  14:45:15      page 4

(  167)       IF(s.GT.0) l=TRIM(l(1:s-1))
(  168)       s=scan(l,';')
(  169)       IF(s.GT.0) l=TRIM(l(1:s-1))
(  170) 
(  171)       IF( ABS(dummy).NE.1) THEN
(  172)          DO i=1,LEN(l)
(  173)             IF(IACHAR(l(i:i)).GT.64.AND.IACHAR(l(i:i)).LT.91) &
(  174)                  l(i:i)=ACHAR(IACHAR(l(i:i))+32)
(  175)          ENDDO
(  176)       ENDIF
(  177) 
(  178)       IF(dummy.LT.0)THEN
(  179)         line=l
(  180)       ELSE
(  181) 
(  182)         DO i=1,LEN(l)
(  183)           IF(l(i:i).EQ.'='.OR.l(i:i).EQ.',') l(i:i)=' '
(  184)        ENDDO
(  185) 
(  186)        IF(l(1:8).NE.'*select:')THEN
(  187)          IF(l(1:1).EQ.'*')THEN
(  188)            s=SCAN(l,' ')
(  189)            IF(s.EQ.0) s=LEN_TRIM(l)+1
(  190)              nugget=TRIM(l(1:s-1))
(  191)              IF(nugget(2:4).EQ.'end')THEN
(  192)                nugget='*'//TRIM(nugget(5:))
(  193) 
(  194)                s=SCAN(here,'*',.TRUE.)
(  195) 
(  196)                parse_out=parse_scan(sel,nugget)
(  197)                IF(sel.NE.''.AND.parse_out.GT.0)THEN
(  198)                  nugget=''
(  199)                ENDIF
(  200) 
(  201)                IF(nugget.GT.'')THEN
(  202)                  string_temp1=TRIM(here(s:))
(  203)                  string_temp2=TRIM(nugget(1:))
(  204)                  IF(string_temp1.NE.string_temp2)THEN
(  205)                    WRITE(*,*) 'l:      ',trim(adjustl(l))
(  206)                    WRITE(*,*) 'nugget: ',trim(adjustl(nugget))
(  207)                    WRITE(*,*) 'here:   ',trim(adjustl(here))
(  208)                    WRITE(*,*) 'sel:    ',trim(adjustl(sel))
(  209)                    CALL report_error('parse_getline','Unmatched */*end pair.')
(  210)                  ELSE
(  211)                    IF(mask.EQ.here) THEN
(  212)                      here=here(1:s-1)
(  213)                      parse_getline=-1
(  214)                      rest='returned_before_eof'
(  215)                      RETURN
(  216)                    ENDIF
(  217)                      here=here(1:s-1)
(  218)                    ENDIF
(  219)                  ENDIF
(  220)                ELSE
(  221)                  parse_out=parse_scan(sel,nugget)
(  222)                  IF(sel.NE.''.AND.parse_out.GT.0)THEN
(  223)                    nugget=''
(  224)                  ENDIF






PGF90 (Version     13.5)          07/18/2014  14:45:15      page 5

(  225) 
(  226)                  here=TRIM(TRIM(here)//nugget)
(  227)                  IF(rest.EQ.'returned_before_eof') rest=''
(  228)                  rest=TRIM(TRIM(rest)//l(s:))
(  229)               ENDIF
(  230)                 line=''
(  231)             ELSE
(  232)               IF(here.EQ.mask.OR.mask.EQ.'')THEN
(  233)                 line=TRIM(l)
(  234)               ELSE
(  235)                 line=''
(  236)               ENDIF
(  237)             ENDIF
(  238)           ELSE
(  239)             sel=TRIM(l(9:))
(  240)             line=''
(  241)           ENDIF
(  242)         ENDIF
(  243) 
(  244)         IF(line.GT.'') EXIT
(  245)      ENDDO
(  246) 
(  247)   END FUNCTION parse_getline
(  248) 
(  249)   RECURSIVE FUNCTION parse_getword(wrap) RESULT(getword)
(  250) 
(  251)     INTEGER                :: stat
(  252)     LOGICAL                :: wrap
(  253)     CHARACTER(LEN=len_max) :: getword,temp
(  254) 
(  255)     INTEGER :: s
(  256) 
(  257)     DO WHILE(line(1:1).EQ.' '.AND.LEN_TRIM(line).GT.0)
(  258)       line=TRIM(line(2:))
(  259)     ENDDO
(  260) 
(  261)     s=SCAN(line,' ')
(  262)     IF(s.EQ.0) s=LEN_TRIM(line)
(  263) 
(  264)     temp=TRIM(line(1:s))
(  265) 
(  266)     IF(temp.EQ.ACHAR(92).OR.(temp.EQ.''.AND.wrap))THEN
(  267)        temp=''
(  268)        stat=parse_getline(dummy)
(  269)        IF(stat.EQ.0) temp=parse_getword(wrap)
(  270)        getword=temp
(  271)     ELSE
(  272)        getword=temp
(  273) 
(  274)        line=TRIM(line(s+1:))
(  275)     ENDIF
(  276) 
(  277)   END FUNCTION parse_getword
(  278) 
(  279)   FUNCTION parse_getival(word)
(  280) 
(  281)     USE clover_module
(  282) 






PGF90 (Version     13.5)          07/18/2014  14:45:15      page 6

(  283)     CHARACTER(LEN=*)  :: word
(  284)     INTEGER         :: temp,parse_getival
(  285) 
(  286)     INTEGER :: ios
(  287) 
(  288)     READ(UNIT=word,FMT="(I7)",IOSTAT=ios) temp
(  289) 
(  290)     IF(ios.NE.0)THEN
(  291)        CALL report_error('parse_getival','Error attempting to convert to integer:'//word)
(  292)        CALL clover_abort
(  293)     ENDIF
(  294) 
(  295)     parse_getival=temp
(  296) 
(  297)   END FUNCTION parse_getival
(  298) 
(  299)   FUNCTION parse_getlval(word)
(  300) 
(  301)     USE clover_module
(  302) 
(  303)     CHARACTER(LEN=*)  :: word
(  304)     LOGICAL :: temp,parse_getlval
(  305) 
(  306)     INTEGER :: ios
(  307) 
(  308)     ios=0
(  309) 
(  310)     SELECT CASE(word)
(  311)        CASE('on')
(  312)           temp=.TRUE.
(  313)        CASE('true')
(  314)           temp=.TRUE.
(  315)        CASE('off')
(  316)           temp=.FALSE.
(  317)        CASE('false')
(  318)           temp=.FALSE.
(  319)        CASE DEFAULT
(  320)           ios=99999
(  321)     END SELECT
(  322) 
(  323)     IF(ios.NE.0)THEN
(  324)        CALL report_error('parse_getlval','Error attempting to convert to logical:'//word)
(  325)        CALL clover_abort
(  326)     ENDIF
(  327) 
(  328)     parse_getlval=temp
(  329) 
(  330)   END FUNCTION parse_getlval
(  331) 
(  332)   FUNCTION parse_getrval(word)
(  333) 
(  334)     USE clover_module
(  335) 
(  336)     CHARACTER(LEN=*) :: word
(  337)     REAL(KIND=8)   :: temp,parse_getrval
(  338) 
(  339)     INTEGER :: ios
(  340) 






PGF90 (Version     13.5)          07/18/2014  14:45:15      page 7

(  341)     ! Make an integer into a float if necessary.
(  342) 
(  343)     IF(SCAN(word,'.').EQ.0) word=TRIM(TRIM(word)//'.0')
(  344) 
(  345)     READ(UNIT=word,FMT="(E27.20)",IOSTAT=ios) temp
(  346) 
(  347)     IF(ios.NE.0)THEN
(  348)        CALL report_error('parse_getrval','Error attempting to convert to real:'//word)
(  349)        CALL clover_abort
(  350)     ENDIF
(  351) 
(  352)     parse_getrval=temp
(  353) 
(  354)   END FUNCTION parse_getrval
(  355) 
(  356)   FUNCTION parse_scan(string,set)
(  357) 
(  358)     ! Improved version of F90 SCAN.
(  359) 
(  360)     INTEGER                     :: parse_scan
(  361)     CHARACTER(LEN=*),INTENT(IN) :: string,set
(  362)     CHARACTER(LEN=LEN_MAX)      :: set_temp
(  363) 
(  364)     INTEGER :: i,l,temp
(  365) 
(  366)     l=LEN_TRIM(set)-1
(  367) 
(  368)     temp=0
(  369)     set_temp=TRIM(set)
(  370)     DO i=1,LEN_TRIM(string)-l
(  371)        IF(string(i:i+l).EQ.set_temp)THEN
(  372)           temp=i
(  373)           EXIT
(  374)        ENDIF
(  375)     ENDDO
(  376) 
(  377)     parse_scan=temp
(  378) 
(  379)   END FUNCTION parse_scan
(  380) 
(  381) END MODULE parse_module
