PGC Version 13.5          07/18/2014  14:45:39      page 1


Switches: -list -object -noxref -nocode -debug -nosingle
          -opt 2  -inform severe   
          -noes 
          -def unix
          -def __unix
          -def __unix__
          -def linux
          -def __linux
          -def __linux__
          -def __NO_MATH_INLINES
          -def __x86_64
          -def __x86_64__
          -def __LONG_MAX__=9223372036854775807L
          -def __SIZE_TYPE__=unsigned long int
          -def __PTRDIFF_TYPE__=long int
          -def __THROW=
          -def __extension__=
          -def __amd_64__amd64__
          -def __k8
          -def __k8__
          -def __SSE__
          -def __MMX__
          -def __SSE2__
          -def __SSE3__
          -def __SSSE3__
          -def #machine(x86_64) #lint(off) #system(posix) #cpu(x86_64)
          -def __pgnu_vsn=40407
          -idir /usr/mpi/pgi/mvapich2-1.7-qlc/include
Filename: initialise_chunk_kernel_c.c

(    1) /*Crown Copyright 2012 AWE.
(    2) *
(    3) * This file is part of CloverLeaf.
(    4) *
(    5) * CloverLeaf is free software: you can redistribute it and/or modify it under
(    6) * the terms of the GNU General Public License as published by the
(    7) * Free Software Foundation, either version 3 of the License, or (at your option)
(    8) * any later version.
(    9) *
(   10) * CloverLeaf is distributed in the hope that it will be useful, but
(   11) * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
(   12) * FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more
(   13) * details.
(   14) *
(   15) * You should have received a copy of the GNU General Public License along with
(   16) * CloverLeaf. If not, see http://www.gnu.org/licenses/. */
(   17) 
(   18) /**
(   19)  *  @brief Driver for chunk initialisation.
(   20)  *  @author Wayne Gaudin
(   21)  *  @details Invokes the user specified chunk initialisation kernel.
(   22)  */
(   23) 
(   24) #include <stdio.h>
(   25) #include <stdlib.h>
(   26) #include "ftocmacros.h"
(   27) #include <math.h>
(   28) 
(   29) void initialise_chunk_kernel_c_(int *xmin,int *xmax,int *ymin,int *ymax,
(   30)                                 double *minx,



PGC Version 13.5          07/18/2014  14:45:39      page 2


(   31)                                 double *miny,
(   32)                                 double *dx,
(   33)                                 double *dy,
(   34)                                 double *vertexx,
(   35)                                 double *vertexdx,
(   36)                                 double *vertexy,
(   37)                                 double *vertexdy,
(   38)                                 double *cellx,
(   39)                                 double *celldx,
(   40)                                 double *celly,
(   41)                                 double *celldy,
(   42)                                 double *volume,
(   43)                                 double *xarea,
(   44)                                 double *yarea)
(   45) {
(   46)   int x_min=*xmin;
(   47)   int x_max=*xmax;
(   48)   int y_min=*ymin;
(   49)   int y_max=*ymax;
(   50)   double min_x=*minx;
(   51)   double min_y=*miny;
(   52)   double d_x=*dx;
(   53)   double d_y=*dy;
(   54) 
(   55)   int j,k;
(   56) 
(   57) #pragma omp parallel
(   58)  {
(   59) #pragma omp for private(j)
(   60) #pragma ivdep
(   61)   for (j=x_min-2;j<=x_max+3;j++) {
(   62)     vertexx[FTNREF1D(j,x_min-2)]=min_x+d_x*(double)(j-x_min);
(   63)   }
(   64) 
(   65) #pragma omp for private(j)
(   66) #pragma ivdep
(   67)   for (j=x_min-2;j<=x_max+3;j++) {
(   68)     vertexdx[FTNREF1D(j,x_min-2)]=d_x;
(   69)   }
(   70) 
(   71) #pragma omp for private(j,k)
(   72) #pragma ivdep
(   73)   for (k=y_min-2;k<=y_max+3;k++) {
(   74)     vertexy[FTNREF1D(k,y_min-2)]=min_y+d_y*(double)(k-y_min);
(   75)   }
(   76) 
(   77) #pragma omp for private(j)
(   78) #pragma ivdep
(   79)   for (k=y_min-2;k<=y_max+3;k++) {
(   80)     vertexdy[FTNREF1D(k,y_min-2)]=d_y;
(   81)   }
(   82) 
(   83) #pragma omp for private(j)
(   84) #pragma ivdep
(   85)   for (j=x_min-2;j<=x_max+2;j++) {
(   86)     cellx[FTNREF1D(j,x_min-2)]=0.5*(vertexx[FTNREF1D(j,x_min-2)]+vertexx[FTNREF1D(j+1,x_min-2)]);
(   87)   }
(   88) 
(   89) #pragma omp for private(j)
(   90) #pragma ivdep



PGC Version 13.5          07/18/2014  14:45:39      page 3


(   91)   for (j=x_min-2;j<=x_max+2;j++) {
(   92)     celldx[FTNREF1D(j,x_min-2)]=d_x;
(   93)   }
(   94) 
(   95) #pragma omp for private(j)
(   96) #pragma ivdep
(   97)   for (k=y_min-2;k<=y_max+2;k++) {
(   98)     celly[FTNREF1D(k,y_min-2)]=0.5*(vertexy[FTNREF1D(k,y_min-2)]+vertexy[FTNREF1D(k+1,x_min-2)]);
(   99)   }
(  100) 
(  101) #pragma omp for private(j)
(  102) #pragma ivdep
(  103)   for (k=y_min-2;k<=y_max+2;k++) {
(  104)      celldy[FTNREF1D(k,y_min-2)]=d_y;
(  105)   }
(  106) 
(  107) #pragma omp for private(j,k)
(  108)   for (k=y_min-2;k<=y_max+2;k++) {
(  109) #pragma ivdep
(  110)     for (j=x_min-2;j<=x_max+2;j++) {
(  111)         volume[FTNREF2D(j,k,x_max+4,x_min-2,y_min-2)]=d_x*d_y;
(  112)     }
(  113)   }
(  114) 
(  115) #pragma omp for private(j,k)
(  116)   for (k=y_min-2;k<=y_max+2;k++) {
(  117) #pragma ivdep
(  118)     for (j=x_min-2;j<=x_max+2;j++) {
(  119)         xarea[FTNREF2D(j,k,x_max+5,x_min-2,y_min-2)]=celldy[FTNREF1D(k,y_min-2)];
(  120)     }
(  121)   }
(  122) 
(  123) #pragma omp for private(j,k)
(  124)   for (k=y_min-2;k<=y_max+2;k++) {
(  125) #pragma ivdep
(  126)     for (j=x_min-2;j<=x_max+2;j++) {
(  127)         yarea[FTNREF2D(j,k,x_max+4,x_min-2,y_min-2)]=celldx[FTNREF1D(j,x_min-2)];
(  128)     }
(  129)   }
(  130) 
(  131)  }
(  132) 
(  133) }




















